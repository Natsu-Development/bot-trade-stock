name: Build and Deploy Trading App

on:
  push:
    branches: [master, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options: [production, staging]

env:
  DOCKER_REGISTRY: ${{ vars.DOCKER_REGISTRY }}
  DOCKER_NAMESPACE: ${{ vars.DOCKER_NAMESPACE }}
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Build and push Docker images to Docker Hub
  build-images:
    runs-on: ubuntu-latest
    environment: production
    outputs:
      registry: ${{ env.DOCKER_REGISTRY }}
      namespace: ${{ env.DOCKER_NAMESPACE }}
      broker-image: ${{ env.DOCKER_NAMESPACE }}/trading-broker:${{ env.IMAGE_TAG }}
      bot-image: ${{ env.DOCKER_NAMESPACE }}/trading-bot:${{ env.IMAGE_TAG }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Debug environment variables
        run: |
          echo "üîç Debugging environment variables:"
          echo "DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}"
          echo "DOCKER_NAMESPACE: ${{ env.DOCKER_NAMESPACE }}"
          echo "IMAGE_TAG: ${{ env.IMAGE_TAG }}"
          echo ""
          echo "üîç Checking secrets availability:"
          echo "DOCKER_USERNAME is set: ${{ secrets.DOCKER_USERNAME != '' && 'YES' || 'NO' }}"
          echo "DOCKER_PASSWORD is set: ${{ secrets.DOCKER_PASSWORD != '' && 'YES' || 'NO' }}"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push broker image
        uses: docker/build-push-action@v5
        with:
          context: broker
          file: broker/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_NAMESPACE }}/trading-broker:${{ env.IMAGE_TAG }}
            ${{ env.DOCKER_NAMESPACE }}/trading-broker:latest
          labels: |
            org.opencontainers.image.title=Trading Broker
            org.opencontainers.image.description=Python gRPC Stock Data Service
            org.opencontainers.image.source=${{ github.repositoryUrl }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push bot image
        uses: docker/build-push-action@v5
        with:
          context: bot-trade
          file: bot-trade/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_NAMESPACE }}/trading-bot:${{ env.IMAGE_TAG }}
            ${{ env.DOCKER_NAMESPACE }}/trading-bot:latest
          labels: |
            org.opencontainers.image.title=Trading Bot
            org.opencontainers.image.description=Go Trading Bot Service
            org.opencontainers.image.source=${{ github.repositoryUrl }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Build deployment configuration
  build-config:
    runs-on: ubuntu-latest
    needs: build-images
    outputs:
      artifact-id: ${{ steps.upload.outputs.artifact-id }}
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base  # Only need envsubst for variable substitution

      - name: Build docker-compose configuration (NO SECRETS)
        env:
          # Export all GitHub Variables as environment variables
          NODE_ENV: ${{ vars.NODE_ENV }}
          GRPC_SERVER_ADDR: ${{ vars.GRPC_SERVER_ADDR }}
          HTTP_PORT: ${{ vars.HTTP_PORT }}
          HTTP_READ_TIMEOUT: ${{ vars.HTTP_READ_TIMEOUT }}
          HTTP_WRITE_TIMEOUT: ${{ vars.HTTP_WRITE_TIMEOUT }}
          HTTP_IDLE_TIMEOUT: ${{ vars.HTTP_IDLE_TIMEOUT }}
          HTTP_SHUTDOWN_TIMEOUT: ${{ vars.HTTP_SHUTDOWN_TIMEOUT }}
          GRPC_CONNECTION_TIMEOUT: ${{ vars.GRPC_CONNECTION_TIMEOUT }}
          GRPC_REQUEST_TIMEOUT: ${{ vars.GRPC_REQUEST_TIMEOUT }}
          GRPC_MARKET_DATA_TIMEOUT: ${{ vars.GRPC_MARKET_DATA_TIMEOUT }}
          RSI_PERIOD: ${{ vars.RSI_PERIOD }}
          RSI_OVERBOUGHT_THRESHOLD: ${{ vars.RSI_OVERBOUGHT_THRESHOLD }}
          RSI_OVERSOLD_THRESHOLD: ${{ vars.RSI_OVERSOLD_THRESHOLD }}
          RSI_EXTREME_OVERBOUGHT_THRESHOLD: ${{ vars.RSI_EXTREME_OVERBOUGHT_THRESHOLD }}
          RSI_EXTREME_OVERSOLD_THRESHOLD: ${{ vars.RSI_EXTREME_OVERSOLD_THRESHOLD }}
          DIVERGENCE_LOOKBACK_LEFT: ${{ vars.DIVERGENCE_LOOKBACK_LEFT }}
          DIVERGENCE_LOOKBACK_RIGHT: ${{ vars.DIVERGENCE_LOOKBACK_RIGHT }}
          DIVERGENCE_RANGE_MIN: ${{ vars.DIVERGENCE_RANGE_MIN }}
          DIVERGENCE_RANGE_MAX: ${{ vars.DIVERGENCE_RANGE_MAX }}
          DIVERGENCE_INDICES_RECENT: ${{ vars.DIVERGENCE_INDICES_RECENT }}
          MIN_ANALYSIS_DAYS: ${{ vars.MIN_ANALYSIS_DAYS }}
          MAX_DATE_RANGE_DAYS: ${{ vars.MAX_DATE_RANGE_DAYS }}
          MIN_SYMBOL_LENGTH: ${{ vars.MIN_SYMBOL_LENGTH }}
          MAX_SYMBOL_LENGTH: ${{ vars.MAX_SYMBOL_LENGTH }}
          CRON_JOB_TIMEOUT: ${{ vars.CRON_JOB_TIMEOUT }}
          BEARISH_CRON_START_DATE_OFFSET: ${{ vars.BEARISH_CRON_START_DATE_OFFSET }}
          BEARISH_CRON_AUTO_START: ${{ vars.BEARISH_CRON_AUTO_START }}
          BEARISH_30M_ENABLED: ${{ vars.BEARISH_30M_ENABLED }}
          BEARISH_30M_SCHEDULE: ${{ vars.BEARISH_30M_SCHEDULE }}
          BEARISH_1H_ENABLED: ${{ vars.BEARISH_1H_ENABLED }}
          BEARISH_1H_SCHEDULE: ${{ vars.BEARISH_1H_SCHEDULE }}
          BEARISH_1D_ENABLED: ${{ vars.BEARISH_1D_ENABLED }}
          BEARISH_1D_SCHEDULE: ${{ vars.BEARISH_1D_SCHEDULE }}
          BEARISH_1W_ENABLED: ${{ vars.BEARISH_1W_ENABLED }}
          BEARISH_1W_SCHEDULE: ${{ vars.BEARISH_1W_SCHEDULE }}
          BULLISH_CRON_START_DATE_OFFSET: ${{ vars.BULLISH_CRON_START_DATE_OFFSET }}
          BULLISH_CRON_AUTO_START: ${{ vars.BULLISH_CRON_AUTO_START }}
          BULLISH_30M_ENABLED: ${{ vars.BULLISH_30M_ENABLED }}
          BULLISH_30M_SCHEDULE: ${{ vars.BULLISH_30M_SCHEDULE }}
          BULLISH_1H_ENABLED: ${{ vars.BULLISH_1H_ENABLED }}
          BULLISH_1H_SCHEDULE: ${{ vars.BULLISH_1H_SCHEDULE }}
          BULLISH_1D_ENABLED: ${{ vars.BULLISH_1D_ENABLED }}
          BULLISH_1D_SCHEDULE: ${{ vars.BULLISH_1D_SCHEDULE }}
          BULLISH_1W_ENABLED: ${{ vars.BULLISH_1W_ENABLED }}
          BULLISH_1W_SCHEDULE: ${{ vars.BULLISH_1W_SCHEDULE }}
          DEFAULT_SYMBOLS: ${{ vars.DEFAULT_SYMBOLS }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}
          TELEGRAM_ENABLED: ${{ vars.TELEGRAM_ENABLED }}
        run: |
          echo "üê≥ Building docker-compose configuration..."
          echo "üîí SECURITY: NO secrets included (injected via SSH during deployment)"

          # Substitute variables directly using envsubst (KISS: one command does it all)
          export DOCKER_REGISTRY="${{ env.DOCKER_NAMESPACE }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          envsubst < docker/docker-compose.prod.yml > docker-compose.final.yml

          # Verify no secrets leaked into artifact
          if grep -E "TELEGRAM_BOT_TOKEN=.{10,}|TELEGRAM_CHAT_ID=[0-9]{5,}" docker-compose.final.yml; then
            echo "‚ùå SECURITY VIOLATION: Secrets found in artifact!"
            exit 1
          fi

          echo "‚úÖ Configuration built successfully - no secrets embedded"

      - name: Create deployment package
        run: |
          echo "üì¶ Creating deployment package..."
          mkdir -p deployment-package

          # Copy final docker-compose file
          cp docker-compose.final.yml deployment-package/docker-compose.yml

          # Copy deployment scripts
          cp -r scripts/ deployment-package/scripts/
          chmod +x deployment-package/scripts/*.sh

          # Create .env.secrets TEMPLATE (not actual secrets)
          cat > deployment-package/.env.secrets.template << 'TEMPLATE_EOF'
          # üîí Secrets Configuration Template
          # This file should be created as .env.secrets on the production VM
          # NEVER commit actual secrets to this file

          # Telegram Bot Configuration
          TELEGRAM_BOT_TOKEN=your_bot_token_here
          TELEGRAM_CHAT_ID=your_chat_id_here
          TEMPLATE_EOF

          # Create deployment README
          cat > deployment-package/DEPLOY_README.md << 'README_EOF'
          # Deployment Instructions

          ## Security Notice
          This artifact does NOT contain any secrets. Secrets must be provided during deployment.

          ## Required Secrets
          Create `.env.secrets` file with:
          - TELEGRAM_BOT_TOKEN
          - TELEGRAM_CHAT_ID

          See `.env.secrets.template` for the format.
          README_EOF

          # Create deployment metadata
          cat > deployment-package/deployment-info.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "git_sha": "${{ github.sha }}",
            "git_ref": "${{ github.ref }}",
            "environment": "${{ github.ref_name == 'master' && 'production' || 'staging' }}",
            "registry": "${{ env.DOCKER_REGISTRY }}",
            "namespace": "${{ env.DOCKER_NAMESPACE }}",
            "images": {
              "broker": "${{ needs.build-images.outputs.broker-image }}",
              "bot": "${{ needs.build-images.outputs.bot-image }}"
            }
          }
          EOF

          echo "üìã Deployment package contents:"
          find deployment-package -type f -exec ls -la {} \;

      - name: Upload deployment artifact
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}
          path: deployment-package/
          retention-days: 30
          compression-level: 6

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # Deploy to VPS
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # This job handles SECURE secret injection at deployment time
  # Secrets are passed via SSH environment variables and created
  # as .env.secrets on production VM only (never stored in artifacts)
  deploy:
    runs-on: ubuntu-latest
    needs: [build-images, build-config]
    environment: ${{ github.ref_name == 'master' && 'production' || 'staging' }}

    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}
          path: deployment-package

      - name: Prepare deployment
        run: |
          echo "üöÄ Preparing deployment to VPS"
          chmod +x deployment-package/scripts/*.sh

          # Show deployment info
          echo "üìã Deployment Information:"
          cat deployment-package/deployment-info.json | jq '.'

      - name: Setup SSH connection
        run: |
          set -e
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          echo "üîç Setting up SSH key..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Debug: Check if secret exists and is not empty
          if [ -z "${{ secrets.VPS_SSH_KEY }}" ]; then
            echo "‚ùå FATAL: VPS_SSH_KEY secret is EMPTY or NOT SET!"
            echo ""
            echo "üìã FIX THIS:"
            echo "1. Go to: GitHub Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Click on 'VPS_SSH_KEY' secret"
            echo "3. Make sure it contains your ACTUAL private key"
            echo "4. The key should start with: -----BEGIN OPENSSH PRIVATE KEY-----"
            exit 1
          fi
          
          # Method 1: Try echo -e (handles \n escape sequences)
          echo "üìù Method 1: Using echo -e..."
          echo -e "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Debug output (safe - doesn't expose key)
          KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
          KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
          KEY_FIRST=$(head -c 50 ~/.ssh/deploy_key)
          KEY_LAST=$(tail -c 50 ~/.ssh/deploy_key | head -c 30)
          
          echo "   Size: ${KEY_SIZE} bytes"
          echo "   Lines: ${KEY_LINES}"
          echo "   Starts with: ${KEY_FIRST}"
          echo "   Ends with: ...${KEY_LAST}"
          
          # Validate Method 1
          if ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null; then
            echo "‚úÖ Method 1 SUCCESS!"
            ssh-keygen -l -f ~/.ssh/deploy_key
          else
            echo "‚ùå Method 1 failed"
            
            # Method 2: Try printf %b (alternative escape handling)
            echo ""
            echo "üìù Method 2: Using printf..."
            printf '%b\n' "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            
            KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
            KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
            echo "   Size: ${KEY_SIZE} bytes"
            echo "   Lines: ${KEY_LINES}"
            
            if ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null; then
              echo "‚úÖ Method 2 SUCCESS!"
              ssh-keygen -l -f ~/.ssh/deploy_key
            else
              echo "‚ùå Method 2 failed"
              
              # Method 3: Try sed conversion (literal \n to newline)
              echo ""
              echo "üìù Method 3: Using sed..."
              echo "${{ secrets.VPS_SSH_KEY }}" | sed 's/\\n/\n/g' > ~/.ssh/deploy_key
              chmod 600 ~/.ssh/deploy_key
              
              KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
              KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
              echo "   Size: ${KEY_SIZE} bytes"
              echo "   Lines: ${KEY_LINES}"
              
              if ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null; then
                echo "‚úÖ Method 3 SUCCESS!"
                ssh-keygen -l -f ~/.ssh/deploy_key
              else
                echo "‚ùå Method 3 failed"
                
                # Method 4: Try base64 decode (if stored as base64)
                echo ""
                echo "üìù Method 4: Trying base64 decode..."
                if echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ~/.ssh/deploy_key 2>/dev/null; then
                  chmod 600 ~/.ssh/deploy_key
                  
                  KEY_SIZE=$(wc -c < ~/.ssh/deploy_key)
                  KEY_LINES=$(wc -l < ~/.ssh/deploy_key)
                  echo "   Size: ${KEY_SIZE} bytes"
                  echo "   Lines: ${KEY_LINES}"
                  
                  if ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null; then
                    echo "‚úÖ Method 4 SUCCESS!"
                    ssh-keygen -l -f ~/.ssh/deploy_key
                  else
                    echo "‚ùå Method 4 failed"
                    echo ""
                    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                    echo "‚ùå ALL METHODS FAILED - SSH KEY IS INVALID!"
                    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                    echo ""
                    echo "üîç DIAGNOSIS:"
                    echo "   Your VPS_SSH_KEY secret is NOT a valid SSH private key!"
                    echo ""
                    echo "   Current content (safe preview):"
                    echo "   - First 80 chars: $(head -c 80 ~/.ssh/deploy_key)"
                    echo "   - Last 80 chars: $(tail -c 80 ~/.ssh/deploy_key)"
                    echo "   - Total size: ${KEY_SIZE} bytes (should be 2500-3500 for RSA, 400-600 for ED25519)"
                    echo "   - Lines: ${KEY_LINES} (should be 25-40 for RSA, 5-10 for ED25519)"
                    echo ""
                    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                    echo "üîß HOW TO FIX:"
                    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                    echo ""
                    echo "Step 1: Get your ACTUAL private key from your local machine"
                    echo "   Run this command on YOUR COMPUTER:"
                    echo "   $ cat ~/.ssh/id_rsa"
                    echo "   (or ~/.ssh/id_ed25519 if you use ED25519)"
                    echo ""
                    echo "Step 2: Copy the ENTIRE output including:"
                    echo "   -----BEGIN OPENSSH PRIVATE KEY-----"
                    echo "   (all the encrypted content)"
                    echo "   -----END OPENSSH PRIVATE KEY-----"
                    echo ""
                    echo "Step 3: Update GitHub Secret"
                    echo "   1. Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
                    echo "   2. Click 'VPS_SSH_KEY' ‚Üí Update"
                    echo "   3. Paste the COMPLETE key (including BEGIN/END lines)"
                    echo "   4. Click 'Update secret'"
                    echo ""
                    echo "Step 4: Verify on VPS that the public key is in authorized_keys"
                    echo "   SSH to your VPS and check:"
                    echo "   $ cat ~/.ssh/authorized_keys"
                    echo "   Should contain the public key matching your private key"
                    echo ""
                    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                    exit 1
                  fi
                else
                  echo "‚ùå Base64 decode failed"
                  echo ""
                  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                  echo "‚ùå ALL METHODS FAILED!"
                  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
                  echo ""
                  echo "Your VPS_SSH_KEY secret appears to be invalid."
                  echo "Please follow the instructions above to fix it."
                  exit 1
                fi
              fi
            fi
          fi
          
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ SSH KEY VALIDATED SUCCESSFULLY"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          
          # Add host to known_hosts
          echo "üîç Adding VPS host to known_hosts..."
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "‚úÖ SSH connection setup completed"

      - name: Copy deployment package to VPS
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ COPYING DEPLOYMENT PACKAGE TO VPS"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          cd deployment-package
          tar czf ../deployment.tar.gz .
          
          PACKAGE_SIZE=$(du -h ../deployment.tar.gz | cut -f1)
          echo "üì¶ Package size: ${PACKAGE_SIZE}"
          echo "üéØ Target: ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/deployment.tar.gz"
          echo ""
          echo "üîÑ Starting transfer..."
          
          # SCP with progress and better error messages
          if scp -v -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o IdentitiesOnly=yes \
            -o ConnectTimeout=30 \
            ../deployment.tar.gz \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/deployment.tar.gz 2>&1 | tee /tmp/scp_output.log; then
            echo ""
            echo "‚úÖ Deployment package copied successfully (${PACKAGE_SIZE})"
          else
            echo ""
            echo "‚ùå SCP FAILED!"
            echo ""
            echo "Error output:"
            cat /tmp/scp_output.log
            echo ""
            echo "Common issues:"
            echo "  - SSH key doesn't match the public key on VPS"
            echo "  - User '${{ secrets.VPS_USER }}' doesn't exist or no shell access"
            echo "  - Firewall blocking SSH port"
            echo "  - Wrong VPS_HOST address"
            exit 1
          fi

      - name: Execute VPS deployment (with secrets injection)
        env:
          # üîí SECRETS: Retrieved from GitHub Secrets and passed via SSH
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üöÄ EXECUTING VPS DEPLOYMENT"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Test SSH connection first
          echo ""
          echo "üîç Testing SSH connection to VPS..."
          if ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o IdentitiesOnly=yes \
            -o ConnectTimeout=10 \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "echo '‚úÖ SSH connection successful'" 2>&1; then
            echo "‚úÖ SSH connection test passed"
          else
            echo "‚ùå SSH connection test FAILED!"
            echo ""
            echo "Troubleshooting:"
            echo "  1. Check if VPS_HOST is correct: ${{ secrets.VPS_HOST }}"
            echo "  2. Check if VPS_USER exists on VPS: ${{ secrets.VPS_USER }}"
            echo "  3. Check if public key is in ~/.ssh/authorized_keys on VPS"
            echo "  4. Try manually: ssh -i ~/.ssh/id_rsa ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}"
            exit 1
          fi
          
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ STARTING DEPLOYMENT SCRIPT ON VPS"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          
          # Execute deployment
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o IdentitiesOnly=yes \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} bash << 'ENDSSH'
            set -e
            set -o pipefail
            
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üì¶ Step 1: Extract deployment package"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            mkdir -p /tmp/deployment-package
            cd /tmp/deployment-package
            
            if [ -f /tmp/deployment.tar.gz ]; then
              echo "‚úÖ Found deployment package"
              tar xzf /tmp/deployment.tar.gz
              echo "‚úÖ Package extracted"
              echo "   Files:"
              ls -lah | head -20
            else
              echo "‚ùå deployment.tar.gz not found!"
              exit 1
            fi
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üîß Step 2: Prepare deployment scripts"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            chmod +x scripts/*.sh
            echo "‚úÖ Scripts are now executable"
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üîí Step 3: Create secrets file"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            cat > .env.secrets << 'ENVEOF'
          TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
          ENVEOF
            
            if [ -f .env.secrets ]; then
              echo "‚úÖ Secrets file created"
              echo "   Variables: $(grep -c '=' .env.secrets) secrets"
            else
              echo "‚ùå Failed to create secrets file!"
              exit 1
            fi
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üöÄ Step 4: Run deployment script"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            
            if [ -f ./scripts/deploy-vps.sh ]; then
              ./scripts/deploy-vps.sh
            else
              echo "‚ùå deploy-vps.sh not found!"
              echo "Available files:"
              find . -type f
              exit 1
            fi
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üßπ Step 5: Cleanup"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            rm -f /tmp/deployment.tar.gz
            echo "‚úÖ Cleanup completed"
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚úÖ DEPLOYMENT COMPLETED SUCCESSFULLY!"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          ENDSSH
          
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üéâ ALL DEPLOYMENT STEPS COMPLETED!"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # Notification and cleanup
  notify:
    runs-on: ubuntu-latest
    needs: [build-images, build-config, deploy]
    environment: production
    if: always() && vars.TELEGRAM_ENABLED == 'true'

    steps:
      - name: Notify deployment status
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          message: |
            üöÄ Trading App Deployment

            Status: ${{ needs.build-images.result == 'success' && needs.build-config.result == 'success' && needs.deploy.result == 'success' && '‚úÖ Deployment Success' || '‚ùå Deployment Failed' }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Environment: ${{ github.ref_name == 'master' && 'Production' || 'Staging' }}
            Registry: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}

            Images Deployed:
            ‚Ä¢ Broker: trading-broker:${{ env.IMAGE_TAG }}
            ‚Ä¢ Bot: trading-bot:${{ env.IMAGE_TAG }}

            Deployment Steps:
            ‚Ä¢ Build Images: ${{ needs.build-images.result == 'success' && '‚úÖ' || '‚ùå' }}
            ‚Ä¢ Build Config: ${{ needs.build-config.result == 'success' && '‚úÖ' || '‚ùå' }}
            ‚Ä¢ Deploy to VPS: ${{ needs.deploy.result == 'success' && '‚úÖ' || '‚ùå' }}

            ${{ needs.deploy.result == 'success' && 'üéâ Application is now running on VPS!' || '‚ö†Ô∏è Deployment failed - check workflow logs' }}

  # Cleanup old artifacts (runs only on master branch after deployment)
  cleanup:
    runs-on: ubuntu-latest
    needs: [deploy]
    environment: production
    if: github.ref == 'refs/heads/master' && needs.deploy.result == 'success'

    steps:
      - name: Setup SSH for cleanup
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%b\n' "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Clean up old Docker images
        continue-on-error: true
        run: |
          echo "üßπ Starting cleanup on VPS..."
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o IdentitiesOnly=yes \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} bash << 'ENDSSH'
            # Clean up old Docker images to save space
            echo "üê≥ Pruning Docker system..."
            docker system prune -f
            docker image prune -f --filter "until=72h"

            # Keep only last 3 backups
            echo "üì¶ Cleaning old backups..."
            cd /opt/trading-app || exit 0
            ls -1t docker-compose.backup.*.yml 2>/dev/null | tail -n +4 | xargs rm -f || true

            echo "‚úÖ Cleanup completed"
          ENDSSH
